<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Outrider</title>
<style>
  :root { color-scheme: dark; }
  html,body { margin:0; height:100%; background:#0d1423; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
  canvas { display:block; width:100vw; height:100vh; image-rendering: pixelated; transition:filter .2s ease; }

  .hud { position:fixed; inset:12px auto auto 12px; display:flex; gap:10px; align-items:center; z-index:10; }
  .bar { width:min(360px, 44vw); height:18px; background:#2a334a; border-radius:9px; overflow:hidden; box-shadow:0 2px 12px rgba(0,0,0,.35) inset, 0 6px 18px rgba(0,0,0,.4); }
  .bar > i { display:block; height:100%; background:linear-gradient(90deg,#ff4d6d,#ff7d6d); transition:width .12s linear; }
  .chip { background:#101a32; color:#e8f0ff; border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:6px 10px; font-weight:700; }
  .hearts { display:flex; gap:4px; }
  .heart { width:14px; height:14px; background:conic-gradient(#ff6d8a 0 25%,#ff3d6a 0 50%,#ff6d8a 0 75%,#ff3d6a 0); transform:rotate(45deg); border-radius:2px; }

  .right { position:fixed; top:12px; right:12px; display:flex; gap:8px; z-index:11; }
  .btn { appearance:none; border:1px solid rgba(255,255,255,.12); background:#0f1a33; color:#e8f0ff; padding:6px 10px; border-radius:10px; cursor:pointer; font-weight:800; }
  .btn.toggled { background:#7dd3fc; color:#0e1726; border-color:transparent; }

  #overlay { position:fixed; inset:0; display:grid; place-items:center; background:linear-gradient(180deg,rgba(5,8,16,.88),rgba(5,8,16,.72) 20%, rgba(5,8,16,.88)); color:#e8f0ff; z-index:20; }
  #overlay .card { width:min(720px, 92vw); background:#0c1528; border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:20px; box-shadow:0 20px 60px rgba(0,0,0,.55); text-align:center; }
  #overlay h1 { margin:0 0 8px; font-size:26px; letter-spacing:.3px; }
  #overlay p  { margin:6px 0 10px; opacity:.9; }
  #overlay .actions { display:flex; gap:10px; justify-content:center; margin-top:10px; }
  #overlay button { appearance:none; border:0; background:#7dd3fc; color:#0e1726; font-weight:900; padding:10px 14px; border-radius:12px; cursor:pointer; }

  #pausedTag { position:fixed; left:50%; top:12px; transform:translateX(-50%); z-index:12; display:none; }
  .toast { position:fixed; top:56px; left:50%; transform:translateX(-50%); background:#0f1a33; color:#e8f0ff; border:1px solid rgba(255,255,255,.12); padding:6px 10px; border-radius:10px; font-weight:800; z-index:12; opacity:.95; display:none; }
</style>
</head>
<body>
  <div class="hud">
    <div class="bar"><i id="hpFill" style="width:100%"></i></div>
    <div class="chip">HP</div>
    <div class="chip" id="scoreChip">Score: 0</div>
    <div class="chip" id="coinChip">Coins: 0</div>
    <div class="chip" id="distChip">Dist: 0</div>
    <div class="chip"><div class="hearts" id="hearts"></div></div>
  </div>

  <div class="right">
    <button class="btn" id="pauseBtn" title="P to toggle">Pause</button>
    <button class="btn" id="musicBtn">Music ON</button>
    <button class="btn" id="nightBtn" title="Night/Day">🌙 Night</button>
  </div>
  <div class="chip" id="pausedTag">Paused</div>
  <div class="toast" id="toast"></div>

  <div id="overlay">
    <div class="card">
      <h1>Pixel Outrider</h1>
      <p>WASD/Space move & jump • Mouse to aim • LMB shoot • <b>RMB/Q charge beam</b> • <b>Shift dash</b> • P pause • H debug</p>
      <p>3 lives • Respawn at last safe ground • HP packs +25% • Boss every ~600 tiles</p>
      <div class="actions"><button id="startBtn">Start</button></div>
    </div>
  </div>

  <canvas id="game"></canvas>
  <audio id="music" loop preload="auto"></audio>

<script>
(() => {
  // ================== Config ==================
  const SETTINGS_KEY = "endlessA16_settings";
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const U = 24 * DPR;

  // soundtrack
  const MUSIC_BASE = "https://cdn.jsdelivr.net/gh/esteves7771/Pixel-Outrider@main/";
  const TRACKS = {
    "-2": "dark-descent-dark-ambience-230662.mp3",
    "-1": "dark-horror-ambience-383336.mp3",
    "0":  "lazy-sunday-chill-lofi-377239.mp3",
    "1":  "relaxed-day-futuristic-chill-250712.mp3",
    "2":  "nice-ambient-futuristic-chill-250714.mp3"
  };
  const MUSIC_BOSS = MUSIC_BASE + "video-game-boss-fiight-259885.mp3";

  let ac, master;
  function initAudio(){
    if (ac) return;
    ac = new (window.AudioContext||window.webkitAudioContext)();
    master = ac.createGain(); master.gain.value = 0.22; master.connect(ac.destination);
  }
  function beep(freq, ms, type='square'){
    if (!ac) return;
    const o = ac.createOscillator(), g = ac.createGain();
    o.type = type; o.frequency.value = freq;
    o.connect(g); g.connect(master);
    const t = ac.currentTime;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.7, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t + ms/1000);
    o.start(t); o.stop(t + ms/1000 + 0.02);
  }
  const sfxCoin = () => { beep(1100, 70, 'square'); beep(2200, 60, 'triangle'); };
  const sfxHeal = () => { beep(600, 120, 'sine'); beep(900, 120, 'sine'); };

  const TUNE = {
    // Feel
    GRAV: 0.52, JUMP: 12, MAX_VX: 5.2, ACCEL: 0.48,
    COYOTE_FRAMES: 6, JUMP_BUFFER_FRAMES: 6,
    // Player fire
    FIRE_CD_MIN: 20, FIRE_CD_MAX: 22, PLAYER_BULLET_SPEED: 14.5,
    // Charge beam
    CHARGE_TIME: 48, CHARGE_COOLDOWN: 180, CHARGE_DMG: 260, CHARGE_SPEED: 22,
    // Dash
    DASH_SPEED: 16, DASH_FRAMES: 12, DASH_CD_FRAMES: 72,
    // Enemy fire
    ENEMY_BULLET_SPEED: 10, ENEMY_CD_MIN: 180, ENEMY_CD_MAX: 240,
    ENEMY_WINDUP: [16,20], AIM_JITTER_DEG: 4, ENEMY_VIEW_FRAMES: 12,
    ENEMY_MAX_RANGE_TILES: 14, ENEMY_BULLET_CAP: 6,
    // World gen
    HP_CHANCE: 0.06, HP_GUARANTEE_TILES: 18,
    COIN_CHANCE: 0.18,
    GEM_MIN_TILES: 400, GEM_MAX_TILES: 600,
    // Movers (base)
    MOVE_AMP: 2.5 * U, MOVE_SPEED: 0.5,
    // Fliers
    FLIER_UNLOCK_DIST: 500 * U, FLIER_CAP: 3,
    // Biomes / tiers
    ALT_MIN: -2, ALT_MAX: 2,
    // Boss
    BOSS_INTERVAL_TILES: 600
  };

  // ================== Canvas ==================
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: true });
  ctx.imageSmoothingEnabled = false;

  let W=0,H=0;
  function resize(){
    W = canvas.width  = Math.floor(innerWidth * DPR);
    H = canvas.height = Math.floor(innerHeight * DPR);
    canvas.style.width  = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    rebuildBGs();
    rebuildPatterns();
  }
  addEventListener('resize', resize);

  // ================== Input ==================
  const keys = new Set();
  const input = { jumpDown:false, jumpPressed:false, up:false, down:false };
  const JUMP_CODES = new Set(['Space','ArrowUp','KeyW']);
  const UP_CODES = new Set(['ArrowUp','KeyW']);
  const DOWN_CODES = new Set(['ArrowDown','KeyS']);

  addEventListener('keydown', e => {
    if (['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
    keys.add(e.code.toLowerCase());
    if (JUMP_CODES.has(e.code) && !input.jumpDown) input.jumpPressed = true;
    if (JUMP_CODES.has(e.code)) input.jumpDown = true;
    if (UP_CODES.has(e.code)) input.up = true;
    if (DOWN_CODES.has(e.code)) input.down = true;
    if (e.code==='KeyP') togglePause();
    if (e.code==='KeyH') debug = !debug;
  });
  addEventListener('keyup', e => {
    keys.delete(e.code.toLowerCase());
    if (JUMP_CODES.has(e.code)) input.jumpDown = false;
    if (UP_CODES.has(e.code)) input.up = false;
    if (DOWN_CODES.has(e.code)) input.down = false;
  });

  const mouse = {x:0,y:0,left:false,right:false};
  canvas.addEventListener('mousemove', e => {
    const r = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - r.left) * DPR;
    mouse.y = (e.clientY - r.top)  * DPR;
  });
  canvas.addEventListener('contextmenu', e=>e.preventDefault());
  canvas.addEventListener('mousedown', e=>{ if(e.button===0) mouse.left=true; if(e.button===2) mouse.right=true; });
  addEventListener('mouseup', e=>{ if(e.button===0) mouse.left=false; if(e.button===2) mouse.right=false; });

  // ================== Helpers ==================
  const cam = {x:0,y:0};
  const toScreenX = wx => Math.round(wx - cam.x);
  const toScreenY = wy => Math.round(wy - cam.y);
  function rand(a,b){ return a + Math.random()*(b-a); }
  function irand(a,b){ return Math.floor(rand(a,b)); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function deg2rad(d){ return d*Math.PI/180; }
  function onScreen(x,y,w,h,margin=40*DPR){ const sx=x-cam.x, sy=y-cam.y; return (sx+w>-margin && sx< W+margin && sy+h>-margin && sy< H+margin); }
  const EPS = 2 * DPR;
  function toast(msg, t=1200){ const el=document.getElementById('toast'); el.textContent=msg; el.style.display='block'; setTimeout(()=>el.style.display='none', t); }

  // ================== Data ==================
  const platforms=[], traps=[], enemies=[], bullets=[], hpPacks=[], coins=[], gems=[], flyers=[], ladders=[], birds=[];
  let genX=0, lastHPAt=0, lastGemAt= -99999, isNight=false, biome='ground', altitude=0;
  let suppressSpawns=false;

  // big-ladder spawn window management
  let nextTierWinStart=Infinity, nextTierWinEnd=Infinity, spawnedTierLadderThisWindow=false;
  function scheduleNextTierWindow(baseTiles){
    nextTierWinStart = Math.floor(baseTiles + 200);
    nextTierWinEnd   = Math.floor(baseTiles + 400);
    spawnedTierLadderThisWindow = false;
  }

  // ================== Sprites ==================
function drawSprite(bitmap, palette, x,y, scale=2){
  const px = Math.max(1, Math.floor(scale*DPR));
  for(let j=0;j<bitmap.length;j++){
    const row = bitmap[j];
    for(let i=0;i<row.length;i++){
      const c=row[i]; if (c==='.') continue;
      ctx.fillStyle = palette[c] || '#000';
      ctx.fillRect((x+i*px)|0, (y+j*px)|0, px, px);
    }
  }
}
function drawSpriteFlipX(bitmap, palette, x,y, scale=2){
  const px = Math.max(1, Math.floor(scale*DPR));
  for(let j=0;j<bitmap.length;j++){
    const row = bitmap[j];
    for(let i=0;i<row.length;i++){
      const c=row[i]; if (c==='.') continue;
      // mirror column
      const mi = (row.length-1)-i;
      ctx.fillStyle = palette[c] || '#000';
      ctx.fillRect((x+mi*px)|0, (y+j*px)|0, px, px);
    }
  }
}

// New hero (chunkier, more detail)
const palPlayer = {
  'o':'#0a0e19', // outline
  's':'#f2c6a2', // skin
  'h':'#ffd36a', // hair
  't':'#7dd3fc', // shirt/cyber vest
  'b':'#394a6b', // pants/boots
  'd':'#1b2744', // deep shadow
  'w':'#cfeaff', // highlight
  'r':'#ff6d8a'  // accent
};
// 18w x 22h
const bmpPlayer = [
  "......hhh.......",
  ".....hhhhh......",
  "....hhhshhh.....",
  "...hhsssss hh...",
  "...hsssssss h...",
  "...hsswssshh....",
  "....osssooo.....",
  "...o ssss  o....",
  "..o tttttt  o...",
  "..o tttttt  o...",
  "..o tttttt  o...",
  "..o tttttt  o...",
  "..o tttttt  o...",
  "...o bbbb o.....",
  "...o bbbb o.....",
  "...o bbbb o.....",
  "..o b    b o....",
  "..o b    b o....",
  "..o b    b o....",
  "...o      o.....",
  "....oooooo......",
  "................"
];

// Enemies you already had (soldier/runner) — keep them:
const palSoldier = {'0':'#0e1726','1':'#22324e','2':'#c7b8ff','3':'#ff7aa2','4':'#91a0ff'};
const bmpSoldier = [
  "...22222222...",
  "..2333333332..",
  "..2333333332..",
  "...23333332...",
  "...23333332...",
  ".111133331111.",
  ".133333333331.",
  ".133333333331.",
  ".133334443331.",
  "..1333333331..",
  "...11111111..."
];
const palRunner = {'a':'#f4b38e','b':'#d98c66','0':'#0e1726'};
const bmpRunner = [
  "...aaaaaaaaaa...",
  "..aaaaaaaaaaaa..",
  ".aaaaaaaaaaaaaa.",
  ".aaaaaaaaaaaaaa.",
  "aaaaaaaaaaaaaaaa",
  ".aaaaaaaaaaaaaa.",
  ".aaaaaaaaaaaaaa.",
  "..aaaaaaaaaaaa..",
  "...bbbbbbbbbb..."
];

// Flyers (keep)
const palFlyer = {'r':'#ff4d6d','R':'#ff9bb0','w':'#ffffff','k':'#0e1726'};
const bmpFlyerWingUp = [
  "...rrrRrrr...",
  "..rrrrrrrr..",
  ".rrrrrrrrrr.",
  ".rrrrwrrrrr.",
  "rrrrr rrrrrr",
  ".rrrrrrrrrr.",
  "..rrrrrrrr..",
  "...rrrRrrr..",
  "....r...r..."
];
const bmpFlyerWingDn = [
  "...rrrRrrr...",
  "..rrrrrrrr..",
  ".rrrrrrrrrr.",
  ".rrrrwrrrrr.",
  "rrrrr rrrrrr",
  "..rrrrrrrr..",
  "...rrrrrr...",
  "....rrrr....",
  ".....r......"
];

// Flame — 4 frames (always visible)
const palFlame = { 'y':'#ffdca8','o':'#ff9a3e','r':'#f2522e','d':'#6b3a2a' };
const FLAME_FRAMES = [
  [
    ".....y......",
    "....yoy.....",
    "...yooo.....",
    "..yoooor....",
    "...yooo.....",
    "....yo......",
    ".....y......",
  ],
  [
    ".....y......",
    "....yoy.....",
    "...yoooy....",
    "..yoooorr...",
    "...yooo.....",
    "....yo......",
    ".....y......",
  ],
  [
    ".....y......",
    "....yo......",
    "...yoooy....",
    "..yoooorr...",
    "...yoooy....",
    "....yoy.....",
    ".....y......",
  ],
  [
    ".....y......",
    "....yoy.....",
    "...yoooy....",
    "..yoooorr...",
    "...yoooy....",
    "....yo......",
    ".....y......",
  ],
];


  // ================== Classes ==================
  class Rect { constructor(x,y,w,h){ this.x=x; this.y=y; this.w=w; this.h=h; }
    get left(){return this.x;} get right(){return this.x+this.w;}
    get top(){return this.y;}  get bottom(){return this.y+this.h;}
    contains(px,py){ return px>=this.left&&px<=this.right&&py>=this.top&&py<=this.bottom; }
    intersects(o){ return this.right>o.left && this.left<o.right && this.bottom>o.top && this.top<o.bottom; } }

  // ---------- Player ----------
  class Player {
    constructor(){
      this.pos = {x:2*U, y:-6*U};
      this.size = {w:0.9*U, h:1.5*U};
      this.vel  = {x:0, y:0};
      this.face = 1;

      this.ladderDir = null;
      this.hp=100; this.alive=true; this.score=0; this.dist=0; this.coins=0;
      this.fireCD=0; this.iframes=0; this.lives=3;
      this.onGround=false; this.coyote=0; this.jumpBuf=0; this.groundedOn=null;
      this.lastSafe = {x:this.pos.x, y:this.pos.y}; this.groundFrames=0;
      this.damageMeter=0;
      this.scoreX2 = 0;
      this.magnet  = 0;
      this.onLadder = null;
      this.ladderT  = 0;

      // dash
      this.dashT=0; this.dashCD=0;
      // charge beam
      this.charging=false; this.chargeT=0; this.chargeCD=0;
      this.trail=[];
    }
    rect(){ return new Rect(this.pos.x, this.pos.y, this.size.w, this.size.h); }

    update(){
      if(!this.alive) return;

      // Dash start
      if (this.dashCD<=0 && this.dashT<=0 && (keys.has('shiftleft')||keys.has('shiftright'))){
        this.dashT = TUNE.DASH_FRAMES;
        this.dashCD = TUNE.DASH_CD_FRAMES;
        this.iframes = Math.max(this.iframes, TUNE.DASH_FRAMES+6);
      }
      if (this.dashCD>0) this.dashCD--;

      // Charge beam logic
      const wantCharge = mouse.right || keys.has('keyq');
      if (!this.charging && this.chargeCD<=0 && wantCharge){
        this.charging = true; this.chargeT = 0;
      }
      if (this.charging){
        this.chargeT++;
        if (!wantCharge){ // release
          if (this.chargeT >= TUNE.CHARGE_TIME){
            const aim = Math.atan2(mouse.y - toScreenY(this.pos.y+this.size.h/2), mouse.x - toScreenX(this.pos.x+this.size.w/2));
            const spd=TUNE.CHARGE_SPEED*DPR;
            const bx=this.pos.x+this.size.w/2+Math.cos(aim)*this.size.w*0.6;
            const by=this.pos.y+this.size.h/2+Math.sin(aim)*this.size.h*0.4;
            bullets.push(new Bullet(bx,by,Math.cos(aim)*spd,Math.sin(aim)*spd,true,TUNE.CHARGE_DMG,2)); // pierce 2
            this.chargeCD = TUNE.CHARGE_COOLDOWN;
          }
          this.charging=false; this.chargeT=0;
        }
      } else {
        if (this.chargeCD>0) this.chargeCD--;
      }

      // Ladder handling
      if (this.onLadder){
        const L = this.onLadder;
        this.ladderT += 0.02;
        const t = Math.min(1, this.ladderT);

        this.vel.x = this.vel.y = 0;
        this.pos.x = L.x + L.w*0.3;

        const goingUp = (L.dir === 'up') || (L.dir === 'link' && this.ladderDir !== 'down');
        const phase   = goingUp ? (1 - t) : t;
        this.pos.y = L.y + phase * L.h - this.size.h;

        this.onGround = false; this.groundedOn = null;

        if (t >= 1){
          if (L.dir === 'up' || L.dir === 'down'){
            const oldAlt = altitude;
            altitude = clamp(altitude + (L.dir === 'up' ? +1 : -1), TUNE.ALT_MIN, TUNE.ALT_MAX);
            biome = altitude>0 ? 'sky' : altitude<0 ? 'depths' : 'ground';
            rebuildBGs();
            toast(altitude>oldAlt ? `Tier +${altitude}` : `Tier ${altitude}`, 1000);
            playTrackForAlt(altitude, {immediate:false});
            scheduleNextTierWindow(this.dist / U);
          }
          this.onLadder = null; this.ladderT = 0; this.ladderDir = null;
          this.lastSafe = {x:this.pos.x, y:this.pos.y};
        }
      } else {
        // horizontal input
        if (keys.has('keya')||keys.has('arrowleft'))  this.vel.x -= TUNE.ACCEL*DPR;
        if (keys.has('keyd')||keys.has('arrowright')) this.vel.x += TUNE.ACCEL*DPR;

        if (this.vel.x>0.1) this.face=1; else if (this.vel.x<-0.1) this.face=-1;

        // Jump buffering / coyote
        if (input.jumpPressed){ this.jumpBuf = TUNE.JUMP_BUFFER_FRAMES; input.jumpPressed = false; }
        if (this.coyote>0 && this.jumpBuf>0){ this.vel.y = -TUNE.JUMP*DPR; this.onGround=false; this.coyote=0; this.jumpBuf=0; }
        if (this.jumpBuf>0) this.jumpBuf--;

        // Physics
        const dashing = this.dashT>0;
        if (dashing){
          this.dashT--;
          this.vel.x = (this.face>0?1:-1) * TUNE.DASH_SPEED*DPR;
          // trail
          this.trail.push({x:this.pos.x, y:this.pos.y, a:0.6});
          if (this.trail.length>8) this.trail.shift();
        }
        this.vel.y += TUNE.GRAV*DPR * (dashing?0.3:1);
        this.vel.x = clamp(this.vel.x, -TUNE.MAX_VX*DPR*1.2, TUNE.MAX_VX*DPR*1.2);

        const MAX_FALL = 22 * DPR;
        if (this.vel.y > MAX_FALL) this.vel.y = MAX_FALL;

        const prevY = this.pos.y;
        this.pos.x += this.vel.x; this.pos.y += this.vel.y;

        let grounded=false, groundPlat=null;

        // Collisions with platforms
        for(const p of platforms){
          if(!p.solid) continue;
          const pr = new Rect(p.x,p.y,p.w,p.h);
          const r  = new Rect(this.pos.x, this.pos.y, this.size.w, this.size.h);

          // landing
          if (this.vel.y > 0 && r.right > pr.left && r.left < pr.right){
            const prevBottom = prevY + this.size.h;
            if (prevBottom <= pr.top + EPS && r.bottom >= pr.top - EPS){
              this.pos.y = pr.top - this.size.h;
              this.vel.y = 0;
              grounded = true; groundPlat = p;
            }
          }
          // head bump
          if (this.vel.y<0 && r.right>pr.left && r.left<pr.right){
            if (r.top <= pr.bottom && prevY >= pr.bottom){
              this.pos.y = pr.bottom; this.vel.y = 0.3*DPR;
            }
          }
          // horizontal resolve
          const rr = new Rect(this.pos.x, this.pos.y, this.size.w, this.size.h);
          if (rr.bottom>pr.top+2 && rr.top<pr.bottom-2){
            if (rr.right>pr.left && rr.left<pr.left && this.vel.x>0){ this.pos.x = pr.left - this.size.w; this.vel.x *= -0.02; }
            else if (rr.left<pr.right && rr.right>pr.right && this.vel.x<0){ this.pos.x = pr.right; this.vel.x *= -0.02; }
          }
        }

        // carry by movers
        if (grounded && groundPlat && groundPlat.dx){
          this.pos.x += groundPlat.dx; this.pos.y += groundPlat.dy;
        }

        this.onGround = grounded; this.groundedOn = grounded ? groundPlat : null;

        // keep feet planted on movers
        if (grounded && groundPlat){
          this.pos.y = Math.min(this.pos.y, groundPlat.y - this.size.h);
          this.pos.y += 0.2 * DPR;
        }

        if (grounded){
          this.coyote = TUNE.COYOTE_FRAMES;
          this.groundFrames++;
          if (this.groundFrames > 8) this.lastSafe = {x:this.pos.x, y:this.pos.y};
        } else {
          this.coyote = Math.max(0, this.coyote - 1);
          this.groundFrames = 0;
        }

        // friction
        this.vel.x *= this.onGround
          ? (this.groundedOn && this.groundedOn.moving ? 0.80 : 0.86)
          : 0.96;

        // Traps (flames are always active/visible now)
          if (this.iframes>0) this.iframes--;
          else for (const t of traps){
            const tr = new Rect(t.x,t.y,t.w,t.h);
          if (this.rect().intersects(tr)){ this.damage(20); this.iframes=90; break; }
        }

        // HP packs
        for (let i=hpPacks.length-1;i>=0;i--){
          const h=hpPacks[i];
          if (this.rect().intersects(new Rect(h.x,h.y,h.w,h.h))){ this.hp=clamp(this.hp+25,0,100); hpPacks.splice(i,1); sfxHeal(); }
        }

        // Coins
        for (let i=coins.length-1;i>=0;i--){
          const c=coins[i];
          const cx=c.x+c.r, cy=c.y+c.r, px=this.pos.x+this.size.w/2, py=this.pos.y+this.size.h/2;
          const dx=px-cx, dy=py-cy, d=Math.hypot(dx,dy);
          if (this.magnet>0 && d<6*U){
            const s = 0.6*DPR; c.vx += (dx/d)*s; c.vy += (dy/d)*s;
          }
          c.x += c.vx||0; c.y += c.vy||0; c.vx*=0.96; c.vy*=0.96;
          if (d < c.r + Math.min(this.size.w,this.size.h)*0.25){
            this.coins++; this.score += (this.scoreX2>0?2:1);
            coins.splice(i,1); sfxCoin();
          }
        }

        // Gems
        for (let i=gems.length-1;i>=0;i--){
          const g=gems[i];
          if (this.rect().intersects(new Rect(g.x,g.y,g.w,g.h))){
            if (g.kind==='ruby'){ this.scoreX2 = Math.max(this.scoreX2, 600); toast('Ruby! 2× score',1000); }
            else               { this.magnet  = Math.max(this.magnet, 600);  toast('Sapphire! Coin magnet',1000); }
            gems.splice(i,1);
          }
        }

        if (this.scoreX2>0) this.scoreX2--;
        if (this.magnet>0)  this.magnet--;

        // Shooting
        if (this.fireCD>0) this.fireCD--;
        const aim = Math.atan2(mouse.y - toScreenY(this.pos.y+this.size.h/2), mouse.x - toScreenX(this.pos.x+this.size.w/2));
        if (mouse.left && this.fireCD<=0 && !this.charging){
          const spd=TUNE.PLAYER_BULLET_SPEED*DPR;
          const bx=this.pos.x+this.size.w/2+Math.cos(aim)*this.size.w*0.6;
          const by=this.pos.y+this.size.h/2+Math.sin(aim)*this.size.h*0.4;
          bullets.push(new Bullet(bx,by,Math.cos(aim)*spd,Math.sin(aim)*spd,true,34,0));
          this.fireCD = irand(TUNE.FIRE_CD_MIN,TUNE.FIRE_CD_MAX);
        }

        this.score += Math.max(0, this.vel.x*0.01) * (this.scoreX2>0?2:1);
        this.dist = Math.max(this.dist, this.pos.x);
        if (this.damageMeter>0) this.damageMeter = Math.max(0, this.damageMeter-0.3);
      }

      // clamp to boss arena if active
      if (boss.active){
        this.pos.x = clamp(this.pos.x, boss.arenaL + 0.5*U, boss.arenaR - this.size.w - 0.5*U);
      }
    }
    damage(n){ this.hp-=n; this.damageMeter += n; if (this.hp<=0) this.consumeLife(); }
    consumeLife(){
      this.lives--;
      if (this.lives>0){
        this.hp=60; this.iframes=90;
        this.pos.x=this.lastSafe.x; this.pos.y=this.lastSafe.y-2*DPR; this.vel.x=0; this.vel.y=0;
        this.score *= 0.9;
      } else { this.hp=0; this.alive=false; gameOver(); }
    }
    fallDeath(){ this.consumeLife(); }
      draw(){
  const sx = toScreenX(this.pos.x)|0;
  const sy = toScreenY(this.pos.y)|0;

  // dash trail
  for (let i=this.trail.length-1;i>=0;i--){
    const t=this.trail[i];
    ctx.globalAlpha = t.a; t.a *= 0.76;
    (this.face>0 ? drawSprite : drawSpriteFlipX)(
      bmpPlayer,
      {'t':'rgba(125,211,252,0.5)','o':'rgba(10,14,25,0.35)','b':'rgba(57,74,107,0.35)','s':'rgba(242,198,162,0.4)'},
      toScreenX(t.x), toScreenY(t.y), 2
    );
    ctx.globalAlpha=1;
    if (t.a<0.05) this.trail.splice(i,1);
  }

  // face toward mouse (mirror)
  const facingRight = mouse.x > sx + this.size.w/2;
  this.face = facingRight ? 1 : -1;
  const paint = facingRight ? drawSprite : drawSpriteFlipX;

  if (isNight){ ctx.globalAlpha=0.35; paint(bmpPlayer, palPlayer, sx-1, sy-1, 2); ctx.globalAlpha=1; }
  paint(bmpPlayer, palPlayer, sx, sy, 2);

  // blaster
  ctx.fillStyle = this.charging ? '#ffe88a' : '#c7b8ff';
  const dir = this.face;
  ctx.fillRect(sx + this.size.w/2 + dir*6*DPR, sy + this.size.h/2, 8*DPR*dir, 2*DPR);

  // charge glow
  if (this.charging){
    const glow = clamp((this.chargeT / TUNE.CHARGE_TIME),0,1);
    ctx.globalAlpha = 0.25 + glow*0.5;
    ctx.fillStyle = '#ffe88a';
    ctx.beginPath();
    ctx.arc(sx+this.size.w/2, sy+this.size.h/2, 10*DPR*(0.6+glow), 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  if (this.scoreX2>0){ ctx.fillStyle='#ff9b5a'; ctx.fillRect(sx-8*DPR, sy, 6*DPR, 6*DPR); }
  if (this.magnet>0){ ctx.fillStyle='#5ad1ff'; ctx.fillRect(sx-8*DPR, sy+8*DPR, 6*DPR, 6*DPR); }
  }
}
  // ---------- Bullet ----------
  class Bullet {
    constructor(x,y,vx,vy,friendly,dmg=12,pierce=0){ this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.friendly=friendly; this.life=180; this.r=2*DPR; this.dmg=dmg; this.pierce=pierce; }
    update(){
      this.x+=this.vx; this.y+=this.vy;
      // stop on solid for non-piercing friendly (piercing ignores platforms)
      if (!this.friendly || this.pierce<=0){
        for(const p of platforms){ if(!p.solid) continue; if(this.x>p.x&&this.x<p.x+p.w&&this.y>p.y&&this.y<p.y+p.h){ this.life=0; return; } }
      }
      if (this.friendly){
        // bosses
        if (boss.active && boss.entity && boss.entity.alive){
          if (this.x>boss.entity.x&&this.x<boss.entity.x+boss.entity.w&&this.y>boss.entity.y&&this.y<boss.entity.y+boss.entity.h){
            boss.hit(this.dmg);
            if (this.pierce>0){ this.pierce--; } else { this.life=0; }
            return;
          }
        }
        for(const e of enemies){ if(!e.alive) continue;
          if (this.x>e.x&&this.x<e.x+e.w&&this.y>e.y&&this.y<e.y+e.h){
            e.hp-=this.dmg;
            if(e.hp<=0){ e.alive=false; player.score += (player.scoreX2>0?50:25); }
            if (this.pierce>0){ this.pierce--; } else { this.life=0; }
            return;
          }
        }
        for(const f of flyers){ if(!f.alive) continue;
          if (this.x>f.x&&this.x<f.x+f.w&&this.y>f.y&&this.y<f.y+f.h){
            f.hp-=this.dmg;
            if(f.hp<=0){ f.alive=false; player.score += (player.scoreX2>0?70:35); if(Math.random()<0.2) spawnCoin(f.x+f.w/2, f.y-6*DPR); }
            if (this.pierce>0){ this.pierce--; } else { this.life=0; }
            return;
          }
        }
      } else {
        const r=player.rect();
        if (this.x>r.left&&this.x<r.right&&this.y>r.top&&this.y<r.bottom){ if(player.iframes<=0) player.damage(this.dmg); this.life=0; return; }
      }
      this.life--;
    }
    draw(){
      const sx=toScreenX(this.x), sy=toScreenY(this.y);
      ctx.beginPath(); ctx.arc(sx,sy,this.r*(this.pierce>0?1.3:1),0,Math.PI*2); ctx.fillStyle = this.friendly?'#ffe88a':'#ff6d8a'; ctx.fill();
      ctx.globalAlpha=0.35; ctx.beginPath(); ctx.moveTo(sx - this.vx*0.5, sy - this.vy*0.5); ctx.lineTo(sx,sy);
      ctx.lineWidth=3*DPR; ctx.strokeStyle=this.friendly?'#fff2b3':'#ff9bb0'; ctx.stroke(); ctx.globalAlpha=1;
    }
  }

  // ---------- Enemies ----------
  class Enemy {
    constructor(x,y,type='soldier'){
      this.kind='ground';
      this.type=type; this.x=x; this.y=y; this.w=(type==='runner'?1.0:0.9)*U; this.h=(type==='runner'?0.9:1.4)*U;
      this.vx=rand(-0.18,0.18)*DPR; this.vy=0; this.hp=(type==='runner')?50:60; this.alive=true;
      this.shootCD=irand(TUNE.ENEMY_CD_MIN,TUNE.ENEMY_CD_MAX); this.windup=0; this.visibleFrames=0; this.blockedFrames=0;
    }
    floorAhead(dir){
      const fx = this.x + (dir>0 ? this.w+2*DPR : -2*DPR);
      const fy = this.y + this.h + 6*DPR;
      for(const p of platforms){ if(!p.solid) continue;
        if (fx>=p.x && fx<=p.x+p.w && Math.abs(fy - p.y) <= 8*DPR) return true;
      }
      return false;
    }
    shortGapHop(dir){
      // is there a platform within a small gap?
      const edgeX = this.x + (dir>0? this.w : 0);
      let best=null;
      for(const p of platforms){
        if(!p.solid) continue;
        const gap = p.x - edgeX;
        if (dir<0) continue; // simple forward-only hop
        if (gap>0 && gap<0.8*U && Math.abs(p.y - (this.y+this.h)) < 0.5*U){ best=p; break; }
      }
      if (best){ this.vx += 0.6*DPR*dir; this.vy = -6*DPR; return true; }
      return false;
    }
    platformCollide(){
      this.vy += (TUNE.GRAV*0.9)*DPR; this.x += this.vx; this.y += this.vy;
      let blocked=false;
      for(const p of platforms){
        if(!p.solid) continue;
        const r=new Rect(this.x,this.y,this.w,this.h), pr=new Rect(p.x,p.y,p.w,p.h);
        if (r.right>pr.left && r.left<pr.right){
          if (r.bottom>pr.top && r.top<pr.top && this.vy>0){ this.y=pr.top-this.h; this.vy=0; }
        }
        if (r.bottom>pr.top+2 && r.top<pr.bottom-2){
          if (r.right>pr.left && r.left<pr.left && this.vx>0){ this.x=pr.left-this.w; blocked=true; }
          else if (r.left<pr.right && r.right>pr.right && this.vx<0){ this.x=pr.right; blocked=true; }
        }
      }
      if (blocked){ this.blockedFrames++; if(this.blockedFrames>20){ this.vx*=-1; this.blockedFrames=0; } } else this.blockedFrames=0;
    }
    update(){
      if(!this.alive) return;

      // avoid falling
      if (Math.abs(this.vx)>0.02){
        const dir = this.vx>0?1:-1;
        if (!this.floorAhead(dir)){
          if (!this.shortGapHop(dir)) this.vx *= -0.8; // turn
        }
      }

      this.platformCollide();

      const dx=(player.pos.x+player.size.w/2)-(this.x+this.w/2);
      const dy=(player.pos.y+player.size.h/2)-(this.y+this.h/2);
      const distTiles = Math.hypot(dx,dy)/U;

      if (onScreen(this.x,this.y,this.w,this.h,40*DPR)) this.visibleFrames++; else this.visibleFrames=0;

      if (this.type==='runner'){
        this.vx += Math.sign(dx)*0.02*DPR; this.vx=clamp(this.vx,-2.0*DPR,2.0*DPR);
        if (new Rect(this.x,this.y,this.w,this.h).intersects(player.rect()) && player.iframes<=0){ player.damage(14); this.vx*=-0.6; }
      } else {
        if (this.visibleFrames>=TUNE.ENEMY_VIEW_FRAMES && distTiles<=TUNE.ENEMY_MAX_RANGE_TILES){
          if (this.windup>0) this.windup--;
          else if (this.shootCD>0) this.shootCD--;
          else { this.windup=irand(TUNE.ENEMY_WINDUP[0],TUNE.ENEMY_WINDUP[1]); this.shootCD=irand(TUNE.ENEMY_CD_MIN,TUNE.ENEMY_CD_MAX); }
          if (this.windup===1){
            const jitter=deg2rad(rand(-TUNE.AIM_JITTER_DEG,TUNE.AIM_JITTER_DEG));
            const a=Math.atan2(dy,dx)+jitter, sp=TUNE.ENEMY_BULLET_SPEED*DPR;
            if (enemyBulletCount()<TUNE.ENEMY_BULLET_CAP) bullets.push(new Bullet(this.x+this.w/2,this.y+this.h/2,Math.cos(a)*sp,Math.sin(a)*sp,false,12,0));
          }
        } else { this.windup=0; }
      }
    }
    draw(){ const sx=toScreenX(this.x)|0, sy=toScreenY(this.y)|0; if(this.type==='runner') drawSprite(bmpRunner,palRunner,sx,sy,2); else drawSprite(bmpSoldier,palSoldier,sx,sy,2); }
  }

  // ---------- Flyers ----------
  class Flyer {
    constructor(x,y,role='swooper'){
      this.kind='flyer';
      this.role=role; this.x=x; this.y=y; this.w=0.9*U; this.h=0.9*U;
      this.hp = role==='gunner'?60:50; this.alive=true;
      this.t   = rand(0,Math.PI*2);
      this.vx=0; this.vy=0;
      this.visibleFrames=0; this.windup=0; this.shootCD=irand(140,200);
      this.diveT=0;
      this.flap=0;
    }
    update(){
      if(!this.alive) return;
      this.t += 0.03;
      this.flap = (Math.sin(this.t*2)>0)?1:0;

      if (onScreen(this.x,this.y,this.w,this.h,40*DPR)) this.visibleFrames++; else this.visibleFrames=0;

      const px=player.pos.x+player.size.w/2, py=player.pos.y+player.size.h/2;
      const dx=px-(this.x+this.w/2), dy=py-(this.y+this.h/2);
      const dist = Math.hypot(dx,dy);

      if (this.role==='swooper'){
        const targetY = py - 3*U + Math.sin(this.t)*0.8*U;
        const targetX = px + Math.cos(this.t*0.6)*2.0*U;
        const k=0.02*DPR;
        this.vx += clamp(targetX - this.x, -3*U, 3*U) * k;
        this.vy += clamp(targetY - this.y, -3*U, 3*U) * k;
        this.vx = clamp(this.vx, -2.2*DPR, 2.2*DPR);
        this.vy = clamp(this.vy, -2.0*DPR, 2.0*DPR);

        if (this.visibleFrames> TUNE.ENEMY_VIEW_FRAMES && this.diveT<=0 && (this.t%6<0.05)){
          this.diveT = 40;
        }
        if (this.diveT>0){
          this.diveT--;
          const a = Math.atan2(dy,dx);
          this.vx += Math.cos(a)*0.3*DPR;
          this.vy += Math.sin(a)*0.3*DPR;
          if (this.diveT<24){
            if (new Rect(this.x,this.y,this.w,this.h).intersects(player.rect()) && player.iframes<=0){ player.damage(18); this.diveT=0; }
          }
        }
      } else {
        const targetY = py - 2.5*U + Math.sin(this.t)*0.6*U;
        const targetX = px + Math.cos(this.t*0.8)*1.6*U;
        const k=0.02*DPR;
        this.vx += clamp(targetX - this.x, -3*U, 3*U) * k;
        this.vy += clamp(targetY - this.y, -3*U, 3*U) * k;
        this.vx = clamp(this.vx, -1.8*DPR, 1.8*DPR);
        this.vy = clamp(this.vy, -1.8*DPR, 1.8*DPR);

        if (this.visibleFrames>=TUNE.ENEMY_VIEW_FRAMES && dist/U <= TUNE.ENEMY_MAX_RANGE_TILES){
          if (this.windup>0) this.windup--;
          else if (this.shootCD>0) this.shootCD--;
          else { this.windup=irand(14,18); this.shootCD=irand(160,220); }
          if (this.windup===1){
            const a=Math.atan2(dy,dx)+deg2rad(rand(-3,3)), sp=TUNE.ENEMY_BULLET_SPEED*DPR;
            if (enemyBulletCount()<TUNE.ENEMY_BULLET_CAP) bullets.push(new Bullet(this.x+this.w/2,this.y+this.h/2,Math.cos(a)*sp,Math.sin(a)*sp,false,12,0));
            if (enemyBulletCount()<TUNE.ENEMY_BULLET_CAP) bullets.push(new Bullet(this.x+this.w/2,this.y+this.h/2,Math.cos(a+deg2rad(4))*sp,Math.sin(a+deg2rad(4))*sp,false,12,0));
          }
        } else this.windup=0;
      }

      this.x += this.vx; this.y += this.vy;
    }
    draw(){
      const sx=toScreenX(this.x)|0, sy=toScreenY(this.y)|0;
      drawSprite(this.flap?bmpFlyerWingUp:bmpFlyerWingDn, palFlyer, sx, sy, 2);
    }
  }

  // ================== World / Traps / Pickups ==================
  function addPlatform(x,y,w,h,type='grass', moving=null){
    // avoid stacking too close
    for (const p of platforms){
      const overlapX = !(x+w < p.x+0.5*U || x > p.x+p.w-0.5*U);
      const tooCloseY = Math.abs((y)-(p.y)) < 0.8*U;
      if (overlapX && tooCloseY) return null;
    }
    const obj={x,y,w,h,solid:true,type, moving, x0:x, y0:y, dx:0, dy:0};
    platforms.push(obj);
    return obj;
  }
  function addSaw(x,y){ if (suppressSpawns) return; traps.push({x,y,w:U*0.9,h:U*0.9,type:'saw',t:rand(0,6.28)}); }
  function addSpikes(x,y,w){ if (suppressSpawns) return; traps.push({x,y,w,h:U*0.4,type:'spike'}); }
  function addFlame(x,y){ if (suppressSpawns) return; traps.push({x,y,w:U*0.8,h:U*1.2,type:'flame',t:0,frame:0}); }
  function addHP(x,y){ if (suppressSpawns) return; hpPacks.push({x,y,w:0.7*U,h:0.5*U}); }
  function spawnCoin(x,y){
    if (suppressSpawns) return;
    for (let i=coins.length-1;i>=Math.max(0, coins.length-12);i--){
      const c=coins[i]; const dx=c.x-x, dy=c.y-y;
      if (dx*dx + dy*dy < (0.55*U)*(0.55*U)) return;
    }
    coins.push({ x:x-0.28*U, y:y-0.28*U, r:0.28*U, vx:0, vy:0, t:0, spin:rand(0.08,0.12) });
  }
  function addGem(x,y,kind){ if (suppressSpawns) return; gems.push({x,y,w:0.6*U,h:0.6*U,kind}); }
  function addLadder(x,y,h,dir){ ladders.push({x:x+0.2*U,y:y-h, w:0.4*U, h, dir}); }

  function tryAddConnectLadder(lower){
    let pick = null;
    for (const up of platforms){
      if (up === lower) continue;
      if (up.y >= lower.y - 0.8*U) continue;
      const dy = lower.y - up.y;
      if (dy < 1.2*U || dy > 6.2*U) continue;

      const L = Math.max(lower.x, up.x) + 0.1*U;
      const R = Math.min(lower.x + lower.w, up.x + up.w) - 0.5*U;
      if (R <= L) continue;

      const x = rand(L, R);
      if (areaHasTrap(x, up.y, 0.6*U, dy)) continue;
      if (ladders.some(Ld => Math.abs((Ld.x+Ld.w/2)-(x+0.2*U)) < 1.2*U &&
                             Math.abs((Ld.y+Ld.h/2) - (up.y + dy/2)) < 1.2*U)) continue;
      pick = {x, y: lower.y, h: dy};
      break;
    }
    if (pick) addLadder(pick.x, pick.y, pick.h, 'link');
  }

  function areaHasTrap(x,y,w,h){ for(const t of traps){ if (x<w+t.x+t.w && x+w>t.x && y<h+t.y+t.h && y+h>t.y) return true; } return false; }
  function enemyBulletCount(){ let n=0; for(const b of bullets) if(!b.friendly) n++; return n; }

  // ================== Backgrounds & Patterns ==================
  const bgCanvas = { day: document.createElement('canvas').getContext('2d'),
                     night: document.createElement('canvas').getContext('2d') };
  bgCanvas.day.imageSmoothingEnabled=false; bgCanvas.night.imageSmoothingEnabled=false;

  const pat = { grass:null, stone:null, metal:null };

  function buildBG(ctx2, mode){
    const w = ctx2.canvas.width, h = ctx2.canvas.height;
    ctx2.clearRect(0,0,w,h);
    const isNightMode = (mode==='night');

    // palette by exact tier flavor
    let b;
    if (altitude >= 2){
      b = isNightMode ? ['#05070f','#090d1a','#0d1326','#111a35'] : ['#0b1633','#12224a','#1c3270','#25488f'];
    } else if (altitude === 1){
      b = isNightMode ? ['#081220','#0d1a2e','#13223d','#19304f'] : ['#1a54f2','#2f6ff8','#4b8cff','#63c3cf'];
    } else if (altitude === 0){
      b = isNightMode ? ['#0b121f','#111a2b','#18243a','#1f2e49'] : ['#15335f','#1d467f','#23539a','#2b66bb'];
    } else if (altitude === -1){
      b = isNightMode ? ['#0a0d16','#0f1320','#151a2a','#1b2235'] : ['#11182a','#151f36','#1a2742','#213051'];
    } else {
      b = isNightMode ? ['#160b15','#1f0f1e','#2a1328','#361632'] : ['#2a1032','#3a1844','#4a2056','#622a6e'];
    }

    const bh=(h*0.5)/b.length;
    for(let i=0;i<b.length;i++){ ctx2.fillStyle=b[i]; ctx2.fillRect(0,(i*bh)|0,w,Math.ceil(bh)); }
    ctx2.fillStyle = isNightMode ? '#152031' :
      (altitude<=-1 ? '#2b1430' : altitude>=1 ? '#20345a' : '#1b2945');
    ctx2.fillRect(0,(h*0.5)|0,w,h);

    // extras per tier
    if (altitude >= 2){
      // starfield
      ctx2.fillStyle = isNightMode ? '#9fb5ff' : '#d4e1ff';
      for(let i=0;i<160;i++){ ctx2.fillRect((i*37)%w, (i*71)%(h*0.45), 1,1); }
      // simple alien ships
      ctx2.fillStyle = isNightMode ? '#b3ffde' : '#8df7cc';
      for(let i=0;i<6;i++){ const x=(i*210+80)%w, y=40+(i%3)*22; ctx2.fillRect(x,y,24,3); ctx2.fillRect(x+6,y-4,12,4); }
    } else if (altitude === 1){
      // clouds
      ctx2.fillStyle = isNightMode ? '#cfd9ff' : '#ffffff';
      for(let i=0;i<12;i++){ const cx=(i*120+40)%w, cy=50+(i%4)*14; ctx2.fillRect(cx,cy,60,10); ctx2.fillRect(cx-10,cy+10,80,10); ctx2.fillRect(cx+15,cy+20,30,10); }
      // birds silhouettes in BG (static layer)
      ctx2.fillStyle = isNightMode ? '#b0c4ff' : '#2b3a55';
      for(let i=0;i<10;i++){ const x=(i*150+30)%w, y=70+(i%3)*16; ctx2.fillRect(x,y,8,2); ctx2.fillRect(x+10,y+2,6,2); }
    } else if (altitude <= -1){
      // lava glow bands & embers (deeper = more)
      const bands = altitude<=-2 ? 4 : 3;
      for(let r=0;r<bands;r++){ ctx2.fillStyle=['#5b1220','#7a1b12','#a42818','#c0392b'][r]; const yy=h*0.55+r*18; for(let x=0;x<w;x+=30){ ctx2.beginPath(); ctx2.arc(x, yy+((x%60)?8:0), 30, Math.PI, 0); ctx2.fill(); } }
      ctx2.fillStyle = isNightMode ? '#ffb55a' : '#ffd08a';
      const emberN = altitude<=-2 ? 140 : 100;
      for(let i=0;i<emberN;i++){ ctx2.fillRect((i*37)%w, (i*53)%(h*0.6), 1,1); }
    } else {
      // default mountains + few clouds
      ctx2.fillStyle = isNightMode ? '#314a82' : '#3a6db6';
      for(let i=-2;i<Math.ceil(w/120)+2;i++){ const mx=i*120+60; ctx2.beginPath(); ctx2.moveTo(mx-60,h*0.48); ctx2.lineTo(mx,h*0.28); ctx2.lineTo(mx+60,h*0.48); ctx2.closePath(); ctx2.fill(); }
      ctx2.fillStyle = isNightMode ? '#cfd9ff' : '#ffffff';
      for(let i=0;i<8;i++){ const cx=(i*140+30)%w, cy=60+(i%3)*12; ctx2.fillRect(cx,cy,60,10); ctx2.fillRect(cx-10,cy+10,80,10); ctx2.fillRect(cx+15,cy+20,30,10); }
    }
  }

  function rebuildBGs(){
    const w=Math.max(1024, Math.ceil(W*1.5)), h=Math.max(480, H);
    bgCanvas.day.canvas.width=w; bgCanvas.day.canvas.height=h;
    bgCanvas.night.canvas.width=w; bgCanvas.night.canvas.height=h;
    buildBG(bgCanvas.day,  'day');
    buildBG(bgCanvas.night,'night');
  }

  function drawBG(){
    ctx.fillStyle = isNight ? '#05070b' : '#1a54f2';
    ctx.fillRect(0,0,W,H);
    const bg = isNight ? bgCanvas.night : bgCanvas.day;
    const tileW = bg.canvas.width, tileH = bg.canvas.height;
    const speed = (altitude>=1?0.12 : altitude<=-1?0.18 : 0.15);
    const off = (-Math.floor((cam.x * speed) % tileW)) | 0;
    for (let x = off; x < W; x += tileW) ctx.drawImage(bg.canvas, x|0, 0, tileW, tileH);

    // vignette stronger on ground/underground
    const vig = (altitude<=0) ? (isNight?0.22:0.14) : (isNight?0.12:0.08);
    if (vig>0){
      const g=ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0,`rgba(0,0,0,${vig})`);
      g.addColorStop(1,`rgba(0,0,0,${vig*1.2})`);
      ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
    }
  }

  // Ambient birds (foreground little sprites)
  class AmbientBird {
    constructor(side){
      this.side=side;
      this.x = side==='L' ? cam.x - 40*DPR : cam.x + W + 40*DPR;
      this.y = cam.y + H*0.25 + rand(-H*0.15, H*0.05);
      this.vx = (side==='L'?1:-1) * rand(1.2,1.8)*DPR;
      this.flap=0; this.life= irand(480, 720);
      this.palette = [{b:'#6b7cff',o:'#ffad66'},{b:'#aae3ff',o:'#6bd6b3'},{b:'#ff6b6b',o:'#ffd166'}][irand(0,3)];
    }
    update(){
      this.x += this.vx; this.flap = (this.flap+1)%20; this.life--;
    }
    draw(){
      const sx=toScreenX(this.x), sy=toScreenY(this.y);
      if (sx<-40||sx>W+40) return;
      ctx.fillStyle='#0e1726';
      ctx.fillRect(sx,sy,6*DPR,3*DPR);
      ctx.fillStyle=this.palette.b; ctx.fillRect(sx+1*DPR, sy- (this.flap<10?1:0)*DPR, 4*DPR,2*DPR);
      ctx.fillStyle=this.palette.o; ctx.fillRect(sx+5*DPR, sy+1*DPR, 1*DPR,1*DPR);
    }
  }

  // Patterns
  function makePatternGrass(){
    const c=document.createElement('canvas'); c.width=c.height=8*DPR; const g=c.getContext('2d'); g.imageSmoothingEnabled=false;
    g.fillStyle='#394a6b'; g.fillRect(0,0,c.width,c.height);
    g.fillStyle='#324260'; for(let y=0;y<c.height;y+=2) for(let x=(y%4?2:0);x<c.width;x+=4) g.fillRect(x,y,1,1);
    return g.createPattern(c,'repeat');
  }
  function makePatternStone(){
    const c=document.createElement('canvas'); c.width=16*DPR; c.height=8*DPR; const g=c.getContext('2d'); g.imageSmoothingEnabled=false;
    g.fillStyle='#556079'; g.fillRect(0,0,c.width,c.height);
    g.fillStyle='#4a546d'; g.fillRect(1,1,c.width-2,1); g.fillRect(1,6,c.width-2,1);
    g.fillStyle='#6a7490'; g.fillRect(8,0,1,c.height);
    return g.createPattern(c,'repeat');
  }
  function makePatternMetal(){
    const c=document.createElement('canvas'); c.width=16*DPR; c.height=8*DPR; const g=c.getContext('2d'); g.imageSmoothingEnabled=false;
    g.fillStyle='#2b3347'; g.fillRect(0,0,c.width,c.height);
    g.fillStyle='#21293a'; g.fillRect(0,0,c.width,1);
    g.fillStyle='#3a435a'; for(let x=2;x<c.width;x+=6) g.fillRect(x,3,2,2);
    return g.createPattern(c,'repeat');
  }
  function rebuildPatterns(){
    pat.grass = makePatternGrass();
    pat.stone = makePatternStone();
    pat.metal = makePatternMetal();
  }

  function drawPlatform(p){
    const sx=toScreenX(p.x), sy=toScreenY(p.y);
    if (sx+p.w<-200||sx>W+200) return;
    ctx.save();
    const pattern = (p.type==='stone')?pat.stone : (p.type==='metal')?pat.metal : pat.grass;
    const offX = (-cam.x|0)%16, offY = (-cam.y|0)%16;
    ctx.translate(offX, offY);
    ctx.fillStyle = pattern;
    ctx.fillRect(sx-offX, sy-offY, p.w, p.h);
    ctx.restore();

    if (p.type==='metal'){
      ctx.fillStyle='#6f7a96'; ctx.fillRect(sx, sy-4*DPR, p.w, 4*DPR);
      if (p.moving){ for(let x=0;x<p.w;x+=12*DPR){ ctx.fillStyle = ((x/ (12*DPR))%2? '#f6c653':'#2b3347'); ctx.fillRect(sx+x, sy-6*DPR, 12*DPR, 2*DPR);} }
    } else if (p.type==='stone'){
      ctx.fillStyle='#6a7490'; ctx.fillRect(sx, sy-4*DPR, p.w, 4*DPR);
      ctx.fillStyle='#485068'; for(let i=0;i<Math.floor(p.w/(24*DPR));i++){ const rx=sx+i*24*DPR+8*DPR; ctx.fillRect(rx, sy-2*DPR, 2*DPR, 2*DPR); }
    } else {
      ctx.fillStyle='#5be38d'; ctx.fillRect(sx, sy-6*DPR, p.w, 6*DPR);
      ctx.fillStyle='#3ec676';
      for(let i=8*DPR;i<p.w;i+=12*DPR){ ctx.fillRect(sx+i, sy-8*DPR, 2*DPR, 2*DPR); ctx.fillRect(sx+i+3*DPR, sy-9*DPR, 2*DPR, 3*DPR); }
    }
  }

  // ================== Generation ==================
  function difficultyMod(){ return 1 - clamp(player.damageMeter/120, 0, 0.25); }
  function enemySpawnChance(){
    const prog = genX / (U*200);
    let base = clamp(0.10 + prog*0.05, 0.10, 0.45) * difficultyMod();
    if (altitude>=1) base *= 0.9;
    if (altitude<=-1) base *= 1.1;
    return base;
  }

  function pickPlatformType(isMover=false){
    if (isMover) return 'metal';
    if (altitude<=-1) return Math.random()<0.7?'stone':'metal';
    if (altitude>=1)  return Math.random()<0.7?'grass':'stone';
    return Math.random()<0.6?'grass':'stone';
  }

  function generateChunk(){
    const width = irand(14, 20) * U;
    const baseY = -irand(2, 8) * U + altitude * U * 1.2;
    let x = genX;
    let lastTop = baseY + irand(-2, 2) * U;

    const tilesWalked = player.dist / U;
    const withinTierWin = tilesWalked >= nextTierWinStart && tilesWalked <= nextTierWinEnd && !spawnedTierLadderThisWindow;

    const archetypes = ['ascend','descend','stairs','gaps','movers'];
    const arch  = withinTierWin ? 'tierLadder' : archetypes[irand(0, archetypes.length)];
    const steps = irand(4,7);
    const bumpAt = irand(1, steps - 1);

    for (let i = 0; i < steps; i++){
      const w   = irand(3,5) * U;
      const gap = (arch === 'gaps') ? irand(3,6) * U : irand(2,4) * U;
      let y     = lastTop;

      if (arch === 'ascend')  y -= irand(0,2) * U;
      if (arch === 'descend') y += irand(0,2) * U;
      if (arch === 'stairs')  y += (i % 2 ? -U*0.8 : U*0.8);
      if (arch !== 'tierLadder' && i === bumpAt) y += (Math.random() < 0.5 ? -U : +U);

      // movers
      let moving = null;
      if (arch === 'movers' && Math.random() < 0.6){
        const tierMul = altitude>=1 ? 1.35 : altitude<=-1 ? 0.9 : 1.15;
        moving = (Math.random() < 0.5)
          ? { ax:1, ay:0, amp:TUNE.MOVE_AMP*rand(0.5,0.9), sp:TUNE.MOVE_SPEED*rand(0.8,1.2)*tierMul, ph:rand(0,6.28) }
          : { ax:0, ay:1, amp:TUNE.MOVE_AMP*rand(0.4,0.7), sp:TUNE.MOVE_SPEED*rand(0.8,1.2)*tierMul, ph:rand(0,6.28) };
      }

      const plat = addPlatform(x, y, w, U*0.8, pickPlatformType(!!moving), moving);
      if (plat){
        if (!suppressSpawns){
          if (Math.random() < (altitude<=-1 ? 0.24 : 0.18)) addSpikes(plat.x + U*0.5, plat.y - 0.4*U, plat.w - U);
          if (Math.random() < (altitude<=-1 ? 0.20 : 0.10)) addFlame(plat.x + plat.w*rand(0.25,0.7), plat.y - U*1.2);
        }

        if (Math.random() < 0.35) tryAddConnectLadder(plat);

        // ground enemies
        if (!suppressSpawns && Math.random() < enemySpawnChance()){
          const ex = plat.x + plat.w*rand(0.25,0.7);
          if (ex - player.pos.x > 6*U){
            const type = (Math.random() < (altitude<=-1 ? 0.3 : 0.5)) ? 'soldier' : 'runner';
            const ey   = type === 'runner' ? plat.y - 0.9*U : plat.y - 1.4*U;
            if (!areaHasTrap(ex-0.2*U, ey-0.2*U, 1.2*U, 1.2*U)) enemies.push(new Enemy(ex, ey, type));
          }
        }

        // coins
        if (!suppressSpawns && Math.random() < TUNE.COIN_CHANCE){
          const pattern = irand(0,3);
          if (pattern === 0){ for (let k=0;k<6;k++) spawnCoin(plat.x + (k+1)*(plat.w/7), plat.y - U*0.8 - Math.sin(k)*4*DPR); }
          if (pattern === 1){ for (let k=0;k<4;k++) spawnCoin(plat.x + k*(plat.w/4),  plat.y - 1.2*U - k*2*DPR); }
          if (pattern === 2){ for (let k=0;k<6;k++) spawnCoin(plat.x + k*(plat.w/6),  plat.y - 0.9*U); }
        }

        // HP & rare gem
        if (!suppressSpawns && (Math.random() < TUNE.HP_CHANCE || (plat.x - lastHPAt) > TUNE.HP_GUARANTEE_TILES*U) &&
            !areaHasTrap(plat.x+U, plat.y-0.6*U, 0.7*U, 0.5*U)){
          addHP(plat.x + plat.w*0.5, plat.y - 0.6*U); lastHPAt = plat.x;
        }
        if (!suppressSpawns && ((plat.x - lastGemAt) > irand(TUNE.GEM_MIN_TILES, TUNE.GEM_MAX_TILES)*U) && Math.random() < 0.6){
          addGem(plat.x + plat.w*0.6, plat.y - 0.9*U, altitude>=1 ? 'sapphire' : 'ruby'); lastGemAt = plat.x;
        }

        // Big tier ladder
        if (!suppressSpawns && arch === 'tierLadder' && i >= 1 && i <= steps - 2){
          const prog = clamp((tilesWalked - nextTierWinStart) / Math.max(1,(nextTierWinEnd-nextTierWinStart)), 0, 1);
          if (Math.random() < (0.12 + 0.20*prog)){
            let dir = 'up';
            if (altitude >= TUNE.ALT_MAX) dir = 'down';
            else if (altitude <= TUNE.ALT_MIN) dir = 'up';
            else dir = (Math.random() < 0.5 ? 'up' : 'down');
            addLadder(plat.x + plat.w*0.5 - 0.2*U, plat.y, 2.6*U, dir);
            spawnedTierLadderThisWindow = true;
            scheduleNextTierWindow(tilesWalked);
          }
        }
      }

      x      += (plat ? (plat.w + gap) : gap);
      lastTop = (plat ? plat.y : y) + irand(-U, U) * 0.2;
    }

    // safety floor and advance generator
    addPlatform(genX - U*6, baseY + U*8, width + U*12, U, 'stone');
    genX += width;

    // flyers
    if (!suppressSpawns && player.dist >= TUNE.FLIER_UNLOCK_DIST && flyers.length < TUNE.FLIER_CAP){
      const weight = altitude>=1 ? 0.6 : altitude<=-1 ? 0.25 : 0.4;
      if (Math.random() < weight){
        const role = Math.random() < 0.5 ? 'swooper' : 'gunner';
        const fx = cam.x + W + 2*U;
        const fy = player.pos.y - 3*U + rand(-U, U);
        flyers.push(new Flyer(fx, fy, role));
      }
    }
  }

  function seedWorld(){
    platforms.length = enemies.length = traps.length = bullets.length = hpPacks.length = coins.length = gems.length = flyers.length = ladders.length = birds.length = 0;
    genX=0; lastHPAt=0; lastGemAt=-99999;
    for(let i=0;i<4;i++) generateChunk();

    // spawn area cleanup (no traps right at start)
    const safe = new Rect((player?.pos?.x ?? 2*U) - 2*U, -8*U, 6*U, 6*U);
    for (let i=traps.length-1;i>=0;i--){
      const t=traps[i]; if (safe.intersects(new Rect(t.x,t.y,t.w,t.h))) traps.splice(i,1);
    }
  }

  // ================== Boss Manager ==================
  const boss = {
    active:false, entity:null, arenaL:0, arenaR:0, nextAt:TUNE.BOSS_INTERVAL_TILES,
    start(){
      this.active=true;
      suppressSpawns=true;
      const mid = player.pos.x + 10*U;
      this.arenaL = mid - W*0.6; this.arenaR = mid + W*0.6;
      this.entity = new BossDuelist(mid + 0.2*W, player.pos.y - 2*U);
      crossfadeTo(MUSIC_BOSS, true);
      toast('⚠️ Boss Incoming!', 1200);
    },
    hit(dmg){ if(!this.entity) return; this.entity.hp-=dmg; if(this.entity.hp<=0){ this.entity.alive=false; this.win(); } },
    win(){
      toast('Arena cleared!', 1400);
      // little reward burst
      for (let i=0;i<16;i++) spawnCoin(player.pos.x+rand(-U,U), player.pos.y - rand(0,U));
      this.active=false; suppressSpawns=false; this.entity=null;
      this.nextAt += TUNE.BOSS_INTERVAL_TILES;
      playTrackForAlt(altitude,{immediate:false});
    },
    update(){
      if(!this.active) return;
      if (this.entity && this.entity.alive) this.entity.update();
    },
    draw(){
  if(!this.active) return;
  if (this.entity) this.entity.draw();

  if (!this.entity) return;
  const hp = Math.max(0,this.entity.hp), max = this.entity.maxHp;
  const pct = clamp(hp/max,0,1);

  // anchor above boss
  const bx = toScreenX(this.entity.x + this.entity.w/2);
  const by = toScreenY(this.entity.y) - 16*DPR;

  const barW = 120*DPR, barH = 8*DPR;
  const x = clamp(bx - barW/2, 8*DPR, W - barW - 8*DPR);
  const y = Math.max(8*DPR, by);

  ctx.fillStyle='rgba(16,26,50,.85)'; ctx.fillRect(x, y, barW, barH);
  ctx.fillStyle='#ff6d8a'; ctx.fillRect(x, y, barW*pct, barH);
  ctx.strokeStyle='rgba(255,255,255,.25)'; ctx.lineWidth=2; ctx.strokeRect(x, y, barW, barH);
}
  };

  class BossDuelist {
    constructor(x,y){
      this.x=x; this.y=y; this.w=1.6*U; this.h=2.2*U;
      this.hp=this.maxHp=800; this.alive=true;
      this.t=0; this.vx=0; this.vy=0; this.phase=0; this.cool=60;
    }
    update(){
      this.t++;
      // simple hover + dash strikes + spreads
      const px=player.pos.x+player.size.w/2, py=player.pos.y+player.size.h/2;
      const dx=px-(this.x+this.w/2), dy=py-(this.y+this.h/2);
      // hover
      const tx = clamp(px + Math.cos(this.t*0.02)*1.2*U, boss.arenaL+1.2*U, boss.arenaR-1.8*U);
      const ty = py - 2.6*U + Math.sin(this.t*0.04)*0.6*U;
      this.vx += clamp(tx - this.x, -3*U, 3*U) * 0.012*DPR;
      this.vy += clamp(ty - this.y, -3*U, 3*U) * 0.012*DPR;
      this.vx = clamp(this.vx, -2.2*DPR, 2.2*DPR);
      this.vy = clamp(this.vy, -2.0*DPR, 2.0*DPR);
      this.x += this.vx; this.y += this.vy;

      // attacks
      if (this.cool>0) this.cool--;
      else {
        if (this.phase===0){ // spread
          const a=Math.atan2(dy,dx);
          for (const off of [-0.15,-0.07,0,0.07,0.15]){
            const sp=TUNE.ENEMY_BULLET_SPEED*1.1*DPR;
            bullets.push(new Bullet(this.x+this.w/2,this.y+this.h/2,Math.cos(a+off)*sp,Math.sin(a+off)*sp,false,14,0));
          }
          this.cool = 70;
          this.phase=1;
        } else { // dash slash (melee)
          const dir = Math.sign(dx)||1;
          this.vx += dir*4.5*DPR; this.vy += Math.sign(dy)*1.2*DPR;
          // melee hitbox
          if (new Rect(this.x-0.3*U, this.y, this.w+0.6*U, this.h).intersects(player.rect()) && player.iframes<=0){
            player.damage(18);
          }
          this.cool = 50; this.phase=0;
        }
      }
    }
    draw(){
      const sx=toScreenX(this.x)|0, sy=toScreenY(this.y)|0;
      // simple tall sprite body
      ctx.fillStyle='#ff6a5a'; ctx.fillRect(sx,sy,this.w,this.h);
      ctx.fillStyle='#2b3a55'; ctx.fillRect(sx+this.w*0.2, sy+this.h*0.8, this.w*0.6, this.h*0.2);
      // horns-ish
      ctx.fillStyle='#7dd3fc'; ctx.fillRect(sx-4*DPR, sy+4*DPR, 4*DPR, 10*DPR);
      ctx.fillRect(sx+this.w, sy+4*DPR, 4*DPR, 10*DPR);
    }
  }

  // ================== Music engine ==================
  const musicBtn = document.getElementById('musicBtn');
  const musicA = document.getElementById('music');
  const musicB = new Audio(); musicB.loop = true; musicB.preload = 'auto';
  let activeAudio = musicA, idleAudio = musicB;
  let musicEnabled = true;

  function currentTrackURLForAlt(alt){
    const key = String(clamp(alt, -2, 2));
    return MUSIC_BASE + TRACKS[key];
  }
  async function crossfadeTo(url, immediate=false){
    if (!musicEnabled) return;
    const curr = activeAudio.currentSrc || '';
    const same = (()=>{ try{ const pa=new URL(curr, location.href).pathname.split('/').pop(); const pb=new URL(url, location.href).pathname.split('/').pop(); return pa===pb; }catch{ return curr===url; }})();
    if (curr && same) return;

    idleAudio.src = url;
    idleAudio.volume = 0.0;

    let idlePlayable = true;
    try { await idleAudio.play(); } catch (e) { idlePlayable = false; }

    if (!idlePlayable) {
      activeAudio.src = url; activeAudio.volume = 0.35; try{ await activeAudio.play(); }catch{}
      return;
    }

    const FADE_MS = immediate ? 0 : 1500;
    const start = performance.now();
    const startVol = activeAudio.volume ?? 0.35;
    const targetVol = 0.35;
    function step(now){
      const t = Math.min(1, (now - start)/FADE_MS || 1);
      activeAudio.volume = startVol * (1 - t);
      idleAudio.volume   = targetVol * t;
      if (t < 1) requestAnimationFrame(step);
      else { activeAudio.pause(); const tmp = activeAudio; activeAudio = idleAudio; idleAudio = tmp; }
    }
    requestAnimationFrame(step);
  }
  async function playTrackForAlt(alt, {immediate=false}={}){
    const url = currentTrackURLForAlt(alt);
    await crossfadeTo(url, immediate);
    musicBtn.textContent='Music ON';
    musicBtn.classList.add('toggled');
  }
  function toggleMusic(){
    musicEnabled = !musicEnabled;
    if (musicEnabled){
      if (!activeAudio.currentSrc) {
        const url = currentTrackURLForAlt(altitude);
        activeAudio.src = url;
      }
      activeAudio.volume = 0.35;
      activeAudio.play().catch(()=>{});
      musicBtn.textContent='Music ON';
      musicBtn.classList.add('toggled');
    } else {
      activeAudio.pause(); idleAudio.pause();
      musicBtn.textContent='Music OFF';
      musicBtn.classList.remove('toggled');
    }
    saveSettings();
  }

    function desiredAmbientURL(){
  return boss.active ? MUSIC_BOSS : currentTrackURLForAlt(altitude);
}
function ensureAmbientTrack(){
  if (!musicEnabled) return;
  const want = desiredAmbientURL();
  const curr = activeAudio.currentSrc || '';
  try{
    const pa = new URL(curr, location.href).pathname.split('/').pop();
    const pb = new URL(want, location.href).pathname.split('/').pop();
    if (pa !== pb) crossfadeTo(want);
  }catch{
    if (curr !== want) crossfadeTo(want);
  }
}

  // ================== Game lifecycle & UI ==================
  let player;
  let running=false, paused=false, debug=false;
  let last=performance.now(), fps=60;

  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const nightBtn = document.getElementById('nightBtn');
  const hpFill = document.getElementById('hpFill');
  const scoreChip = document.getElementById('scoreChip');
  const coinChip = document.getElementById('coinChip');
  const distChip = document.getElementById('distChip');
  const heartsEl = document.getElementById('hearts');
  const pausedTag = document.getElementById('pausedTag');

  startBtn.onclick = async () => {
    initAudio(); try { await ac?.resume(); } catch {}
    startGame();

    const firstURL = currentTrackURLForAlt(altitude);
    activeAudio.src = firstURL; activeAudio.volume = 0.35;
    musicEnabled = true; musicBtn.textContent = 'Music ON'; musicBtn.classList.add('toggled');
    try { await activeAudio.play(); } catch { musicEnabled = false; musicBtn.textContent = 'Music OFF'; musicBtn.classList.remove('toggled'); toast('Click “Music ON” to start audio', 1600); }
  };
  pauseBtn.onclick = togglePause;
  musicBtn.onclick = toggleMusic;
  nightBtn.onclick = ()=>setNight(!isNight);

  function renderHearts(n){ heartsEl.innerHTML=''; for(let i=0;i<n;i++){ const d=document.createElement('div'); d.className='heart'; heartsEl.appendChild(d); } }

  function startGame(){
    player = new Player(); altitude=0; biome='ground';
    scheduleNextTierWindow(0);
    seedWorld();
    cam.x = player.pos.x - W*0.3; cam.y = player.pos.y - H*0.55;
    overlay.style.display='none'; running=true; paused=false; pausedTag.style.display='none';
    rebuildBGs();
  }
  function togglePause(){ if(!running) return; paused=!paused; pauseBtn.classList.toggle('toggled',paused); pausedTag.style.display=paused?'block':'none'; }
  function setNight(v){ isNight=v; nightBtn.classList.toggle('toggled',v); nightBtn.textContent = v ? '🌙 Night' : '☀️ Day'; rebuildBGs(); saveSettings(); }

  function gameOver(){
    running=false;
    overlay.innerHTML = `
      <div class="card">
        <h1>Game Over</h1>
        <p>Score: <b>${Math.floor(player.score)}</b> • Coins: <b>${player.coins}</b> • Dist: <b>${Math.floor(player.dist/U)}</b> tiles</p>
        <div class="actions"><button id="restartBtn">Restart</button></div>
      </div>`;
    overlay.style.display='grid';
    overlay.querySelector('#restartBtn').onclick = () => { location.reload(); };
    const s=loadSettings(); s.bestScore=Math.max(s.bestScore||0,Math.floor(player.score)); s.bestDist=Math.max(s.bestDist||0,Math.floor(player.dist/U)); localStorage.setItem(SETTINGS_KEY, JSON.stringify(s));
  }

  function loadSettings(){ try{ return JSON.parse(localStorage.getItem(SETTINGS_KEY)||'{}'); }catch{ return {}; } }
  function saveSettings(){
    const s=loadSettings();
    s.night=isNight;
    s.musicOn=musicEnabled;
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(s));
  }

  // ================== Main loop ==================
  function loop(t=0){
    requestAnimationFrame(loop);
    if(!running) return;

    const dt = t - last; last = t; fps = 1000 / Math.max(1, dt);

    if (paused){ drawFrame(); return; }

    // Boss trigger
    if (!boss.active && (player.dist/U) >= boss.nextAt){
      boss.start();
    }

    // Move moving platforms
    for (const p of platforms){
      p.dx = 0; p.dy = 0;
      if (p.moving){
        const oldX = p.x, oldY = p.y;
        const tt = performance.now()/1000 * p.moving.sp + p.moving.ph;
        const nx = p.x0 + (p.moving.ax ? Math.sin(tt)*p.moving.amp : 0);
        const ny = p.y0 + (p.moving.ay ? Math.sin(tt)*p.moving.amp : 0);
        let ok = true;
        for (const q of platforms){
          if (q === p || !q.solid) continue;
          const pr = {x:nx,y:ny,w:p.w,h:p.h}, qr = {x:q.x,y:q.y,w:q.w,h:q.h};
          const inter = !(pr.x+pr.w<=qr.x || pr.x>=qr.x+qr.w || pr.y+pr.h<=qr.y || pr.y>=qr.y+qr.h);
          if (inter){ ok = false; break; }
        }
        if (ok){ p.x = nx; p.y = ny; p.dx = p.x - oldX; p.dy = p.y - oldY; }
      }
    }

    // Camera
    cam.x += (player.pos.x - W*0.35 - cam.x)*0.06;
    cam.y += (player.pos.y - H*0.58 - cam.y)*0.05;

    // generate more (suppressed during boss only for enemies/items/traps)
    while (genX - cam.x < W*1.2) generateChunk();

    player.update();
    boss.update();

    // fall-death safeguard
    const FALL_TILES = 12;
    if (!player.onGround && !player.onLadder) {
      if (player.pos.y > player.lastSafe.y + FALL_TILES * U) {
        player.fallDeath();
      }
    }

    for (const e of enemies) e.update();
    for (const f of flyers)  f.update();
    for (const b of bullets) b.update();

    // flames: simple 4-frame loop
    for (const t2 of traps) if (t2.type==='flame'){
      t2.t += 0.15;
      t2.frame = Math.floor(t2.t) % 4;
    }

    // Ambient birds spawn (only at tiers 0/1/2)
    if (altitude>=0 && Math.random()<0.006 && !boss.active){
      birds.push(new AmbientBird(Math.random()<0.5?'L':'R'));
    }
    for (let i=birds.length-1;i>=0;i--){ const b=birds[i]; b.update(); if (b.life<=0) birds.splice(i,1); }

    // ladders: enter on overlap + input
    if (!boss.active) {
      for (const L of ladders){
        const r = new Rect(L.x, L.y, L.w, L.h);
        if (!player.onLadder && player.rect().intersects(r)){
          if (L.dir === 'link'){
            if (input.up || input.down){
              player.onLadder = L; player.ladderT = 0;
              player.ladderDir = input.down ? 'down' : 'up';
            }
          } else if ((L.dir === 'up' && input.up) || (L.dir === 'down' && input.down)){
            player.onLadder = L; player.ladderT = 0;
            player.ladderDir = L.dir;
          }
        }
      }
    }

    // cull offscreen / dead things
    for (let i=bullets.length-1;i>=0;i--) if (bullets[i].life<=0) bullets.splice(i,1);
    for (let i=enemies.length-1;i>=0;i--) if (!enemies[i].alive && Math.random()<0.02) enemies.splice(i,1);
    for (let i=flyers.length-1;i>=0;i--)  if (!flyers[i].alive  && Math.random()<0.03) flyers.splice(i,1);
    for (let i=hpPacks.length-1;i>=0;i--){ const h=hpPacks[i]; if (toScreenX(h.x+h.w)<-200) hpPacks.splice(i,1); }
    for (let i=coins.length-1;i>=0;i--){ const c=coins[i]; if (toScreenX(c.x)    <-200) coins.splice(i,1); }
    for (let i=gems.length-1;i>=0;i--){  const g=gems[i];  if (toScreenX(g.x)    <-200) gems.splice(i,1); }

    drawFrame();
  }

  function drawWorld(){
    // platforms
    for(const p of platforms) drawPlatform(p);

    // traps
    for(const t of traps){
      const sx=toScreenX(t.x), sy=toScreenY(t.y);
      if (sx+t.w<-100||sx>W+100) continue;
      if (t.type==='saw'){
  t.t += 0.08;
  ctx.save();
  ctx.translate((sx+t.w/2)|0,(sy+t.h/2)|0);
  ctx.rotate(t.t);
  ctx.fillStyle='#ffd3aa';
  ctx.beginPath();
  for(let i=0;i<12;i++){
    const a=(i/12)*Math.PI*2;
    ctx.moveTo(0,0);
    ctx.lineTo(Math.cos(a)*t.w*0.55, Math.sin(a)*t.h*0.55);
  }
  ctx.closePath(); ctx.fill();
  ctx.restore();

} else if (t.type==='flame'){
  // burner base
  const baseH = 4*DPR;
  ctx.fillStyle = palFlame.d;
  ctx.fillRect(sx, sy+t.h-baseH, t.w, baseH);

  // 4-frame pixel flame (always visible)
  const f = FLAME_FRAMES[t.frame|0];
  const scale = Math.min( t.w/(f[0].length), (t.h-baseH)/f.length ) * 1.1;
  const fx = sx + (t.w - f[0].length*scale)/2;
  const fy = sy + (t.h - baseH - f.length*scale);

  for(let j=0;j<f.length;j++){
    const row=f[j];
    for(let i=0;i<row.length;i++){
      const c=row[i]; if(c==='.') continue;
      ctx.fillStyle=palFlame[c]||'#fff';
      const px = (fx+i*scale)|0, py = (fy+j*scale)|0, sz = Math.max(1,scale)|0;
      ctx.fillRect(px, py, sz, sz);
    }
  }

  } else {
    // spikes
      ctx.fillStyle='#c7b8ff';
      const teeth=Math.max(2,Math.floor(t.w/(8*DPR)));
    for(let i=0;i<teeth;i++){
      const x2=sx+(i/teeth)*t.w;
      ctx.beginPath();
      ctx.moveTo(x2,sy+t.h); ctx.lineTo(x2+t.w/teeth/2,sy); ctx.lineTo(x2+t.w/teeth,sy+t.h);
      ctx.fill();
    }
  }
}
    // ambient birds
    if (altitude>=0){ for (const b of birds) b.draw(); }

    function drawCoin(c){
      c.t += c.spin || 0.1;
      const sx = toScreenX(c.x)|0, sy = toScreenY(c.y)|0;
      const R  = c.r;
      const phase = (Math.sin(c.t) + 1) * 0.5;
      const rx = Math.max(2*DPR, R*(0.35 + 0.65*phase));
      const ry = R;

      ctx.save();
      ctx.translate((sx+R)|0, (sy+R)|0);

      ctx.beginPath();
      ctx.ellipse(0,0, rx, ry, 0, 0, Math.PI*2);
      ctx.fillStyle = '#ffd75a';
      ctx.fill();
      ctx.lineWidth = 1*DPR;
      ctx.strokeStyle = '#c99a2f';
      ctx.stroke();

      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.ellipse(-rx*0.25, -ry*0.15, rx*0.35, ry*0.35, 0, 0, Math.PI*2);
      ctx.fillStyle = '#fff6b0';
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.fillStyle = '#caa032';
      ctx.fillRect(-rx*0.1, -ry*0.6, 2*DPR, ry*1.2);

      ctx.restore();
    }

    // ladders
    for (const L of ladders){
      const sx=toScreenX(L.x), sy=toScreenY(L.y);
      ctx.fillStyle='#a77d4b';
      ctx.fillRect(sx, sy, L.w, L.h);
      ctx.fillStyle='#d1a774';
      for(let y=0;y<L.h;y+=10*DPR) ctx.fillRect(sx-4*DPR, sy+y, L.w+8*DPR, 2*DPR);
      ctx.fillStyle='#e8f0ff';
      if (L.dir==='up'){ ctx.fillRect(sx+L.w+4*DPR, sy, 2*DPR, 8*DPR); ctx.fillRect(sx+L.w+2*DPR, sy+2*DPR, 6*DPR, 2*DPR); }
      else if (L.dir==='down'){ ctx.fillRect(sx+L.w+4*DPR, sy+L.h-8*DPR, 2*DPR, 8*DPR); ctx.fillRect(sx+L.w+2*DPR, sy+L.h-4*DPR, 6*DPR, 2*DPR); }
    }

    // hp packs
    for(const h of hpPacks){
      const sx=toScreenX(h.x), sy=toScreenY(h.y);
      ctx.fillStyle='#2dd4bf'; ctx.fillRect(sx,sy,h.w,h.h);
      ctx.fillStyle='#0e1726'; ctx.fillRect(sx+h.w/2-2*DPR, sy+2*DPR, 4*DPR, h.h-4*DPR);
      ctx.fillRect(sx+2*DPR, sy+h.h/2-2*DPR, h.w-4*DPR, 4*DPR);
    }

    for (const c of coins) drawCoin(c);

    for (const g of gems){
      const sx=toScreenX(g.x), sy=toScreenY(g.y);
      ctx.fillStyle = g.kind==='ruby'? '#ff6a5a' : '#5ad1ff';
      ctx.fillRect(sx,sy,g.w,g.h);
      ctx.fillStyle='#e8f0ff'; ctx.fillRect(sx+2*DPR, sy+2*DPR, g.w-4*DPR, 2*DPR);
    }

    for(const e of enemies) if(e.alive) e.draw();
    for(const f of flyers)  if(f.alive) f.draw();
    for(const b of bullets) b.draw();

    if (boss.active) boss.draw();

    player.draw();
  }

  function drawFrame(){
    drawBG();
    drawWorld();

    // HUD
    scoreChip.textContent = 'Score: ' + Math.floor(player.score);
    coinChip.textContent  = 'Coins: ' + player.coins;
    distChip.textContent  = 'Dist: ' + Math.floor(player.dist/U);
    hpFill.style.width = clamp(player.hp,0,100)+'%';
    renderHearts(player.lives);

    if (debug){
      ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(10,10,360,112);
      ctx.fillStyle='#e8f0ff'; ctx.font=`${12*DPR}px monospace`;
      ctx.fillText(`FPS: ${fps.toFixed(0)}`, 20, 28);
      ctx.fillText(`Enemies: ${enemies.length} + Fliers: ${flyers.length}`, 20, 44);
      ctx.fillText(`Bullets: ${bullets.length} • Alt: ${altitude} (${biome})`, 20, 60);
      ctx.fillText(`Tier win: ${nextTierWinStart}|${nextTierWinEnd} • seen=${spawnedTierLadderThisWindow}`, 20, 76);
      ctx.fillText(`Boss@ ${boss.nextAt} • Active=${boss.active}`, 20, 92);
    }
  }

  // ================== Boot ==================
  function initSettings(){
    resize();
    const s=loadSettings();
    setNight(!!s.night);
    musicEnabled = !!s.musicOn;
    musicBtn.textContent = musicEnabled ? 'Music ON' : 'Music OFF';
    musicBtn.classList.toggle('toggled', musicEnabled);
    nightBtn.classList.toggle('toggled', isNight);
  }

  addEventListener('keydown', e=>{ if(e.code==='KeyR' && !running) location.reload(); });

  initSettings();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
